<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quantum Clash - eSport Launch</title>
  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;500;800&display=swap" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Exo 2', sans-serif;
    }
    canvas {
      display: block;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1.5s ease-in-out;
      z-index: 10;
    }
    #overlay.active {
      opacity: 1;
    }
    #overlay h1 {
      font-size: 5em;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      background: linear-gradient(45deg, #00ffcc, #ff00ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 20px rgba(0, 255, 204, 0.8), 0 0 35px rgba(255, 0, 255, 0.7);
      opacity: 0;
      animation: fadeInUp 1.2s ease-out forwards;
      animation-delay: 0.8s;
    }
    #overlay p {
      font-size: 1.8em;
      font-weight: 400;
      color: #e0f7fa;
      max-width: 700px;
      margin: 20px 0;
      text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
      opacity: 0;
      animation: fadeInUp 1.2s ease-out forwards;
      animation-delay: 1.4s;
    }
    #overlay button {
      pointer-events: auto;
      margin-top: 30px;
      padding: 18px 50px;
      font-size: 1.5em;
      font-weight: 600;
      background: linear-gradient(45deg, #ff00ff, #00ffcc);
      border: none;
      border-radius: 60px;
      color: #fff;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.2, 0.8, 0.7, 0.9);
      box-shadow: 0 0 25px rgba(0, 255, 204, 0.8);
      opacity: 0;
      animation: fadeInUp 1.2s ease-out forwards;
      animation-delay: 2s;
    }
    #overlay button:hover {
      transform: scale(1.1) translateY(-5px);
      box-shadow: 0 0 40px rgba(0, 255, 204, 1);
    }
    @keyframes fadeInUp {
      0% {
        opacity: 0;
        transform: translateY(30px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @media (max-width: 768px) {
      #overlay h1 {
        font-size: 3em;
        letter-spacing: 0.1em;
      }
      #overlay p {
        font-size: 1.3em;
        max-width: 90%;
      }
      #overlay button {
        font-size: 1.2em;
        padding: 14px 36px;
      }
    }
  </style>
</head>
<body>
  <div id="overlay">
    <h1>Quantum Clash</h1>
    <p>Unleash Your Power in the Ultimate eSport Arena!</p>
    <button id="joinButton" onclick="window.open('https://yourstore.com', '_blank');">Join the Revolution</button>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/",
        "cannon": "https://cdn.jsdelivr.net/npm/cannon-es@6.0.1/dist/cannon-es.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as CANNON from 'cannon';

    // Scene Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x1a1a3a, 0.4);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0x00ccff, 1.2);
    mainLight.position.set(5, 10, 5);
    mainLight.castShadow = true;
    scene.add(mainLight);

    const backLight = new THREE.DirectionalLight(0xff00ff, 0.8);
    backLight.position.set(-5, -2, -10);
    scene.add(backLight);

    const glowLight = new THREE.PointLight(0x00ffcc, 2.5, 15);
    glowLight.position.set(0, 0, -4);
    scene.add(glowLight);

    // Nebula Background
    const bgGeometry = new THREE.SphereGeometry(100, 64, 64);
    const bgMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        colorA: { value: new THREE.Color(0x000033) },
        colorB: { value: new THREE.Color(0x330066) },
        colorC: { value: new THREE.Color(0x00ffcc) }
      },
      vertexShader: `
        varying vec3 vPosition;
        void main() {
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 colorA;
        uniform vec3 colorB;
        uniform vec3 colorC;
        varying vec3 vPosition;
        void main() {
          vec3 color = mix(colorA, colorB, sin(vPosition.x * 0.1 + time) * 0.5 + 0.5);
          color = mix(color, colorC, pow(length(vPosition.xy) * 0.05 + sin(time * 0.5) * 0.1, 2.0));
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      side: THREE.BackSide
    });
    const nebula = new THREE.Mesh(bgGeometry, bgMaterial);
    scene.add(nebula);

    // Desk (Futuristic)
    const deskGeometry = new THREE.BoxGeometry(20, 0.5, 10);
    const deskMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a1a3a,
      roughness: 0.6,
      metalness: 0.4,
      emissive: 0x003344,
      emissiveIntensity: 0.3
    });
    const desk = new THREE.Mesh(deskGeometry, deskMaterial);
    desk.position.y = -2.5;
    desk.receiveShadow = true;
    scene.add(desk);

    // Physics World
const world = new CANNON.World();
world.gravity.set(0, -10, 0); // Gravity pulls down (Y-negative)
world.broadphase = new CANNON.NaiveBroadphase(); // Or use GridBroadphase for better performance
world.solver.iterations = 16;
world.allowSleep = true; // Improves performance for static objects

    const deskShape = new CANNON.Box(new CANNON.Vec3(10, 0.25, 5));
    const deskBody = new CANNON.Body({ mass: 0 });
    deskBody.addShape(deskShape);
    deskBody.position.copy(desk.position);
    world.addBody(deskBody);

    // Monitors
    const monitors = [];
    const monitorGeometry = new THREE.BoxGeometry(3, 2, 0.1);
    const frameGeometry = new THREE.BoxGeometry(3.2, 2.2, 0.3);
    for (let i = 0; i < 3; i++) {
      const monitor = new THREE.Group();
      const screenMaterial = new THREE.MeshStandardMaterial({
        color: 0x001122,
        emissive: 0x00ffcc,
        emissiveIntensity: 0,
        roughness: 0.1,
        metalness: 0.8,
        transparent: true,
        opacity: 0
      });
      const screen = new THREE.Mesh(monitorGeometry, screenMaterial);
      screen.position.z = 0.05;
      screen.receiveShadow = true;

      const frame = new THREE.Mesh(frameGeometry, new THREE.MeshStandardMaterial({ color: 0x222222 }));
      frame.add(screen);
      frame.position.set((i - 1) * 3.5, -1.5, -5);
      frame.rotation.y = (i - 1) * 0.15;
      monitor.add(frame);
      scene.add(monitor);
      monitors.push({ group: monitor, screen, material: screenMaterial });
    }

    // Loading Text
    const loadingTextGeometry = new THREE.PlaneGeometry(2.2, 0.6);
    const loadingTextMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffcc,
      transparent: true,
      opacity: 0,
      side: THREE.DoubleSide
    });
    const loadingTexts = [];
    for (let i = 0; i < 3; i++) {
      const text = new THREE.Mesh(loadingTextGeometry, loadingTextMaterial);
      text.position.set((i - 1) * 3.5, -1.5, -4.9);
      text.rotation.y = (i - 1) * 0.15;
      scene.add(text);
      loadingTexts.push(text);
    }

    // Quantum Logo (Shader)
    let logo = null;
    const logoLoader = new GLTFLoader();
    logoLoader.load(
      'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/main/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb',
      (gltf) => {
        logo = gltf.scene;
        logo.scale.set(0, 0, 0);
        logo.position.set(0, -1.5, -5);
        logo.traverse((child) => {
          if (child.isMesh) {
            child.material = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                glowColor: { value: new THREE.Color(0x00ffcc) },
                pulse: { value: 0 }
              },
              vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                  vNormal = normalize(normalMatrix * normal);
                  vPosition = position;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position + normal * sin(time * 2.0) * 0.02, 1.0);
                }
              `,
              fragmentShader: `
                uniform vec3 glowColor;
                uniform float time;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                  float intensity = pow(0.95 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                  vec3 glow = glowColor * intensity * (0.8 + 0.2 * sin(time * 5.0));
                  gl_FragColor = vec4(mix(vec3(0.1, 0.1, 0.2), glow, intensity * 1.5), 1.0);
                }
              `,
              transparent: true,
              blending: THREE.AdditiveBlending
            });
            child.castShadow = true;
          }
        });
        scene.add(logo);
      },
      undefined,
      (error) => console.warn('Logo load failed:', error.message)
    );

    // Character (Fallback if model fails)
    let character = null;
    let mixer = null;
    let characterBody = null;

    const characterLoader = new GLTFLoader();
    const modelUrl = './models/jinx.glb'; // Replace with your hosted model

    characterLoader.load(
      modelUrl,
      (gltf) => setupCharacter(gltf),
      undefined,
      () => {
        console.warn('Primary model failed. Loading fallback...');
        // Try direct public URL (if hosted)
        const fallbackUrl = 'https://example.com/models/jinx.glb'; // Replace with real public URL
        characterLoader.load(fallbackUrl, setupCharacter, undefined, createFallbackCharacter);
      }
    );

    function setupCharacter(gltf) {
      character = gltf.scene;
      character.scale.set(1, 1, 1);
      character.position.set(-10, -1.5, -3);
      character.rotation.y = Math.PI / 2;
      character.castShadow = true;
      scene.add(character);

      const shape = new CANNON.Box(new CANNON.Vec3(0.4, 0.9, 0.4));
      characterBody = new CANNON.Body({ mass: 1 });
      characterBody.addShape(shape);
      characterBody.position.set(-10, -1.5, -3);
      world.addBody(characterBody);

      if (gltf.animations.length > 0) {
        mixer = new THREE.AnimationMixer(character);
        const action = mixer.clipAction(gltf.animations[0]);
        action.play();
      }
    }

    function createFallbackCharacter() {
      console.log('Using fallback cube character.');
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 1.2, 0.4),
        new THREE.MeshStandardMaterial({ color: 0xff4d94, roughness: 0.5 })
      );
      const head = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.4, 0.4),
        new THREE.MeshStandardMaterial({ color: 0xffb6c1 })
      );
      head.position.y = 0.8;
      character = new THREE.Group();
      character.add(body, head);
      character.position.set(-10, -1.5, -3);
      character.castShadow = true;
      scene.add(character);

      const shape = new CANNON.Box(new CANNON.Vec3(0.3, 0.6, 0.2));
      characterBody = new CANNON.Body({ mass: 1 });
      characterBody.addShape(shape);
      characterBody.position.set(-10, -1.5, -3);
      world.addBody(characterBody);
    }

    // Particles
    const particleCount = 300;
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount * 3; i += 3) {
      positions[i] = (Math.random() - 0.5) * 10;
      positions[i + 1] = (Math.random() - 0.5) * 10;
      positions[i + 2] = (Math.random() - 0.5) * 10;
      velocities[i] = (Math.random() - 0.5) * 0.02;
      velocities[i + 1] = (Math.random() - 0.5) * 0.02;
      velocities[i + 2] = (Math.random() - 0.5) * 0.02;
    }
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00ffcc,
      size: 0.06,
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending
    });
    const particles = new THREE.Points(particlesGeometry, particleMaterial);
    scene.add(particles);

    // Camera
    camera.position.set(0, 1, 10);
    camera.lookAt(0, -1.5, -5);

    // Animation State
    let time = 0;
    let phase = 0;
    let characterState = 'idle';
    let characterTime = 0;
    let glitchActive = false;
    let flickerCount = 0;
    let glitchStartTime = 0;

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      time += 0.05;

      // Update physics
      world.step(1 / 60);

      // Sync character
      if (character && characterBody) {
        character.position.copy(characterBody.position);
        character.position.y = -1.5;
      }

      // Update shaders
      nebula.material.uniforms.time.value = time;
      if (logo) logo.traverse(c => c.isMesh && (c.material.uniforms.time.value = time));

      // Phase 0: Monitors On (0–4s)
      if (phase === 0 && time > 4) {
        monitors.forEach((m, i) => {
          if (time > i * 1.2 + 0.5) {
            const t = (time - i * 1.2) * 0.3;
            m.material.opacity = Math.min(t, 1);
            m.material.emissiveIntensity = m.material.opacity * 0.8;
          }
        });
        if (time > 4) phase = 1;
      }

      // Phase 1: Loading Text (4–8s)
      if (phase === 1) {
        loadingTexts.forEach((text, i) => {
          const delay = 4 + i * 0.8;
          if (time > delay) {
            text.material.opacity = Math.min((time - delay) * 0.5, 1);
          }
        });
        if (time > 8) {
          loadingTexts.forEach(t => t.material.opacity = 0);
          phase = 2;
        }
      }

      // Phase 2: Logo Appears (8–12s)
      if (phase === 2 && logo) {
        if (logo.scale.x < 1.5) {
          logo.scale.x += 0.02;
          logo.scale.y += 0.02;
          logo.scale.z += 0.02;
        } else {
          phase = 3;
        }
      }

      // Phase 3: Character Walk In, Glitch, Walk Out (12–21s)
      if (phase === 3 && character && characterBody) {
        if (characterState === 'idle') characterState = 'walkingIn';

        if (characterState === 'walkingIn') {
          characterBody.velocity.x = 0.03 * 60;
          if (mixer) mixer.update(0.016);
          if (characterBody.position.x >= -2) {
            characterBody.velocity.set(0, 0, 0);
            characterState = 'glitching';
            glitchActive = true;
            glitchStartTime = time;
            flickerCount = 0;
          }
        }

        if (characterState === 'glitching' && time - glitchStartTime > 2) {
          characterState = 'walkingOut';
        }

        if (characterState === 'walkingOut') {
          characterBody.velocity.x = 0.05 * 60;
          if (mixer) mixer.update(0.016);
          if (characterBody.position.x > 10) {
            characterBody.position.x = -10;
            characterBody.velocity.set(0, 0, 0);
            phase = 4;
          }
        }

        // Glitch effect
        if (glitchActive && time - glitchStartTime < 2) {
          if (Math.random() < 0.15 && flickerCount < 5) {
            monitors.forEach(m => {
              m.material.opacity = 0.3;
              m.material.emissiveIntensity = 0;
            });
            if (logo) logo.traverse(c => c.isMesh && (c.material.uniforms.glowColor.value.setHex(0xff00ff)));
            setTimeout(() => {
              monitors.forEach(m => {
                m.material.opacity = 1;
                m.material.emissiveIntensity = 0.8;
              });
              if (logo) logo.traverse(c => c.isMesh && (c.material.uniforms.glowColor.value.setHex(0x00ffcc)));
            }, 100);
            flickerCount++;
          }
        }
      }

      // Phase 4: Fullscreen Zoom (21–22s)
      if (phase === 4 && logo) {
        if (logo.scale.x < 8) {
          logo.scale.multiplyScalar(1.05);
          logo.position.z += 0.2;
          camera.position.z -= 0.1;
          monitors.forEach(m => m.group.scale.multiplyScalar(0.95));
        } else {
          phase = 5;
          setTimeout(() => {
            document.getElementById('overlay').classList.add('active');
          }, 200);
        }
      }

      // Update particles
      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] += velocities[i];
        positions[i + 1] += velocities[i + 1];
        positions[i + 2] += velocities[i + 2]; // ✅ Fixed: was missing ']'
        if (Math.abs(positions[i]) > 10) velocities[i] *= -1;
        if (Math.abs(positions[i + 1]) > 10) velocities[i + 1] *= -1;
        if (Math.abs(positions[i + 2]) > 10) velocities[i + 2] *= -1;
      }
      particlesGeometry.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }

    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
