<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quantum Clash - eSport Logo Animation</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      font-family: 'Orbitron', sans-serif;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s ease-in-out;
    }
    #overlay.active { opacity: 1; }
    #overlay h1 {
      font-size: 4.5em;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      background: linear-gradient(45deg, #00ffcc, #ff00ff, #00ccff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: glow 1.5s ease-in-out infinite alternate;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
    }
    #overlay p {
      font-size: 1.6em;
      color: #e0e0e0;
      max-width: 600px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    #overlay button {
      pointer-events: auto;
      margin-top: 20px;
      padding: 15px 30px;
      font-size: 1.2em;
      background: linear-gradient(45deg, #ff00ff, #00ffcc);
      border: none;
      border-radius: 25px;
      color: #fff;
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
    }
    #overlay button:hover {
      transform: scale(1.1);
      box-shadow: 0 0 25px rgba(0, 255, 255, 1);
    }
    @keyframes glow {
      from { text-shadow: 0 0 10px #00ffcc, 0 0 20px #ff00ff; }
      to { text-shadow: 0 0 20px #00ccff, 0 0 30px #ff00ff; }
    }
    @media (max-width: 768px) {
      #overlay h1 { font-size: 2.5em; }
      #overlay p { font-size: 1.2em; }
      #overlay button { font-size: 1em; padding: 10px 20px; }
    }
  </style>
</head>
<body>
  <div id="overlay">
    <h1>Quantum Clash</h1>
    <p>The eSport That Shatters Reality - Join the Revolution!</p>
    <button onclick="window.location.href='https://yourstore.com'">Enter the Arena</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0x00ffcc, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    const pointLight = new THREE.PointLight(0xff00ff, 1, 100);
    pointLight.position.set(-10, -10, 10);
    scene.add(pointLight);

    // Desk (Simple plane for context)
    const deskGeometry = new THREE.PlaneGeometry(20, 10);
    const deskMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
    const desk = new THREE.Mesh(deskGeometry, deskMaterial);
    desk.rotation.x = -Math.PI / 2;
    desk.position.y = -2;
    scene.add(desk);

    // Three Monitors
    const monitors = [];
    const monitorGeometry = new THREE.BoxGeometry(3, 2, 0.2);
    const monitorScreenMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0 });
    const monitorFrameMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
    for (let i = 0; i < 3; i++) {
      const monitor = new THREE.Group();
      const screen = new THREE.Mesh(monitorGeometry, monitorScreenMaterial);
      const frame = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.2, 0.3), monitorFrameMaterial);
      monitor.add(screen, frame);
      monitor.position.set((i - 1) * 4, 0, -5);
      monitor.rotation.y = (i - 1) * 0.2; // Slight angle for realism
      scene.add(monitor);
      monitors.push({ group: monitor, screen });
    }

    // Logo (Torus Knot for a complex, futuristic "Quantum Clash" symbol)
    const logoGeometry = new THREE.TorusKnotGeometry(0.5, 0.1, 100, 16, 2, 3);
    const logoMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        glowColor: { value: new THREE.Color(0x00ffcc) }
      },
      vertexShader: `
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 glowColor;
        varying vec3 vNormal;
        void main() {
          float intensity = pow(0.8 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
          gl_FragColor = vec4(glowColor * intensity, 1.0) * (sin(time) * 0.5 + 0.5);
        }
      `
    });
    const logo = new THREE.Mesh(logoGeometry, logoMaterial);
    logo.scale.set(0, 0, 0); // Start hidden
    scene.add(logo);

    // Particle System (Sparkles around logo)
    const particleCount = 500;
    const particlesGeometry = new THREE.BufferGeometry();
    const posArray = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount * 3; i += 3) {
      posArray[i] = (Math.random() - 0.5) * 10;
      posArray[i + 1] = (Math.random() - 0.5) * 10;
      posArray[i + 2] = (Math.random() - 0.5) * 10;
      velocities[i] = (Math.random() - 0.5) * 0.05;
      velocities[i + 1] = (Math.random() - 0.5) * 0.05;
      velocities[i + 2] = (Math.random() - 0.5) * 0.05;
    }
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const particleMaterial = new THREE.PointsMaterial({
      color: 0xff00ff,
      size: 0.1,
      transparent: true,
      blending: THREE.AdditiveBlending
    });
    const particles = new THREE.Points(particlesGeometry, particleMaterial);
    scene.add(particles);

    // Background Shader (Subtle cyberpunk ambiance)
    const bgGeometry = new THREE.PlaneGeometry(100, 100);
    const bgMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec2 resolution;
        varying vec2 vUv;
        void main() {
          vec2 uv = vUv * 2.0 - 1.0;
          float d = length(uv);
          vec3 color = vec3(0.05, 0.1, 0.2) * (sin(d * 3.0 - time) * 0.5 + 0.5);
          gl_FragColor = vec4(color, 1.0);
        }
      `
    });
    const bg = new THREE.Mesh(bgGeometry, bgMaterial);
    bg.position.z = -50;
    scene.add(bg);

    camera.position.set(0, 2, 10);
    camera.lookAt(0, 0, -5);

    // Animation Timeline
    let time = 0;
    let phase = 0; // 0: Monitors light up, 1: Logo appears, 2: Flicker and fullscreen, 3: Overlay reveal
    function animate() {
      requestAnimationFrame(animate);
      time += 0.05;

      // Phase 0: Monitors light up
      if (phase === 0) {
        monitors.forEach((monitor, i) => {
          const delay = i * 0.5;
          if (time > delay && monitor.screen.material.opacity < 1) {
            monitor.screen.material.opacity += 0.1;
            monitor.screen.material.color.setHex(0x00ffcc);
          }
        });
        if (time > 2.5) {
          phase = 1;
        }
      }

      // Phase 1: Logo appears on monitors
      if (phase === 1) {
        if (logo.scale.x < 1) {
          logo.scale.x += 0.05;
          logo.scale.y += 0.05;
          logo.scale.z += 0.05;
          logo.position.set(0, 0, -5);
        }
        if (time > 4) {
          phase = 2;
        }
      }

      // Phase 2: Flicker and fullscreen
      if (phase === 2) {
        // Flicker effect
        if (time % 0.2 > 0.1) {
          monitors.forEach(monitor => {
            monitor.screen.material.opacity = 0.5;
          });
        } else {
          monitors.forEach(monitor => {
            monitor.screen.material.opacity = 1;
          });
        }
        // Zoom logo to fullscreen
        if (logo.scale.x < 3) {
          logo.scale.x += 0.1;
          logo.scale.y += 0.1;
          logo.scale.z += 0.1;
          logo.position.z += 0.2;
          camera.position.z -= 0.1; // Pull camera back slightly
          monitors.forEach(monitor => {
            monitor.group.scale.x *= 0.9;
            monitor.group.scale.y *= 0.9;
            monitor.group.scale.z *= 0.9;
          });
        }
        if (time > 6) {
          phase = 3;
          document.getElementById('overlay').classList.add('active');
        }
      }

      // Phase 3: Logo rotates and particles move
      logo.rotation.x += 0.01;
      logo.rotation.y += 0.01;
      logoMaterial.uniforms.time.value = time;
      bgMaterial.uniforms.time.value = time;

      // Animate particles
      const positions = particlesGeometry.attributes.position.array;
      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] += velocities[i];
        positions[i + 1] += velocities[i + 1];
        positions[i + 2] += velocities[i + 2];
        if (Math.abs(positions[i]) > 5) velocities[i] *= -1;
        if (Math.abs(positions[i + 1]) > 5) velocities[i + 1] *= -1;
        if (Math.abs(positions[i + 2]) > 5) velocities[i + 2] *= -1;
      }
      particlesGeometry.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }
    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      bgMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
